use strict;
use Data::Dumper;
use Carp;

my $LineLength = 80;

## Script bodies
my $TheNucleus; ## See below
my $MpPlayDeclare;
my $MpPlayBody;

my $LogFile = "log.txt";

my $MidiCsvPath = "$ENV{HOME}/CeeGuitar/midicsv-1.1/midicsv";

## Maschines transpose knob only supports -48 semitones -> +48 semitones. So when
## we import we only consider this note range. Compile supports all notes.
my $MinImportNote = 12;
my $MaxImportNote = 108;

my $MinChokeGroup     = 0;
my $MaxChokeGroup     = 15;
my $DefaultChokeGroup = 0;
my $DefaultChannel    = 0;
## Tool that takes midi file, and slice_note, and produces a new file
## $LEX.$CHANNEL.$NOTE$SIGNED_TRANSPOSE.<user-text-with-no_><options>_sl960.mid 
## Here $SIGNED_TRANSPOSE and $NOTE are redundant. $SIGNED_TRANSPOSE is 
## a positive or negative offset from C3. It's used in maschine. $SIGNED_TRANSPOSE
## always starts with a + or - (+0). 

my @Letters52 = ("A" .. "Z", "a" .. "z");
my @NoteSymbols = qw/ C   C#  D  D#  E   F   F#  G  G#  A A# B  /;

my %KnownConfigFields = (
    ## import options
    sn => {name=>"SliceNote", arg=>"Integer specifies which note to consider the split note"},
    ic => {name=>"InputChannel", arg=>"Integer specifies which input channel the midi file MUST be imported into"},
    
    ## compile options
    cg => {name=>"ChokeGroup", arg=>"Integer specifies choke group (0-15)"},
    ch => {name=>"OutputChannel", arg=>"Integer specifies output channel (0-15)"},
    ln => {name=>"Length", arg=>"Integer describes length (in bars) of the sequence"},
    sl => {name=>"Slice", arg=>"Integer specifies where to slice a loop"},
    lp => {name=>"Loop", arg=>"NONE", desc=>"If present indicates that loop should loop instead of stoping at end of seq"},
    zt => {name=>"ZeroTime", arg=>"NONE", desc=>"If present, all of the midi events of the sequence are played at time zero"},
    es => {name=>"ExclusiveSlice", arg=>"NONE", 
        desc=>"If present means that, rather than playing entire sequence, only plays events between slice markers"},

);

my %com2com = (
    'Note_on_c'    => '$A',
    'Note_off_c'   => '$O',
    'Pitch_bend_c' => '$P',
    'Control_c'    => '$C',
);

sub dd {
    print Dumper(@_), "\n";
}

sub backtick {
    my ($command) = @_;
    my @lines = `$command`;
    if ($?) {
        confess "Failed '$command': $!";
    }
    chomp(@lines);
    return @lines;
}

sub run {
    my ($cmd) = @_;
    if (system $cmd){
        confess "Failed: '$cmd': $!";
    }
}

sub now {
    my ($d) = backtick 'date +"%F %T"';
    return $d;
}

sub isint {
    my ($v) = @_;
    return $v =~ /^\d+/;
}

sub note_from_text {
    my ($text) = @_;
    if ($text =~ /^\d+$/){
        confess "INTERNAL ERROR [1]: bad note" unless $text >= 0 && $text < 128;    
        return $text;
    }

    die "note_from_text got a bunk note: '$text'" unless $text =~ /([^\d]+)([-+]?\d)/;

    my $l = uc($1);
    $l =~ s/s/#/; ## We accept s for # -- so it's nicer to work with on command line
    (my $n = $2) =~ s/^\+//;
    
    my $offset = -1;
    for (my $i = 0; $i < @NoteSymbols; $i++){
        if ($NoteSymbols[$i] eq $l){
            $offset = $i;
            last;
        }
    }
    confess "Failed to find offset for note-letter $l" unless $offset >= 0;
    my $note = ($n+2)*12 + $offset;
    confess "INTERNAL ERROR [2]: bad note" unless $note >= 0 && $note < 128;

    return $note;
}


sub scan_filename_meta {
    my ($filename) = @_;
    my $original = $filename;
    $filename =~ s/\.mid$//;
    my @fields = split "_", $filename;

    ## The first segment does not contain config variables
    shift @fields;

    my %meta;
    for my $f (@fields){
        next unless $f;
        my ($name, $value) = ($f =~ /([^\d][^\d])(.*)/);
        $value = "" unless defined($value);
        confess "Bad field found in $original" unless defined($name) && $name;
        my $cfg = $KnownConfigFields{$name};
        confess "Unknown field $name found in $original" if (!defined($cfg));
        confess "Found argument in boolean config variable $name in $original" if ($value && $cfg->{arg} eq 'NONE');

        $meta{$name} = $value;
    }
    
    return \%meta;
}

sub lex_from_chan_note {
    my ($inChannel, $inNote) = @_;
    my $index = $inChannel * 128 + $inNote;
    return $Letters52[int($index/52)] . $Letters52[int($index % 52)];
}

## NOTE: transpose in this context is the transpose setting in maschine that gets you back to the note. 
## So maschine always transposes from middle-C (note 60)
sub transpose_from_note {
    my ($note) = @_;
    return sprintf "%+d", ($note-60);
}

## list all midi files in directory that conform to the above format. Return them as $files->{$CHANNEL_$NOTE}
sub list_compile_files {
    my @ls = backtick("ls *.mid");
    @ls = grep {/^[A-Za-z][A-Za-z]\.\d{1,2}\.\d{1,3}[-+]\d{1,2}/} @ls;
    my %files;
    for my $file (@ls){
        my ($ch, $note) = parse_chan_note($file);
        $files{"${ch}.${note}"} = $file;
    }
    @ls = sort {$a <=> $b} @ls;
    return (\%files, \@ls);
}   

sub list_noncompile_files {
    my ($files) = list_compile_files();
    my %mp;
    for my $k (keys(%$files)){
        $mp{$files->{$k}} = 1;
    }
    my @ls = backtick("ls *.mid");
    return [grep {!$mp{$_}} @ls];
}

sub parse_chan_note {
    my ($arg) = @_;
    my ($chan, $note) = ($arg =~ /(\d{1,2})\.(\d{1,3})/);
    confess "parse_chan_note passed bad argument $arg" unless defined($note);
    confess "parse_chan_note bad channel parsed out of $arg" unless $chan >= 0 && $chan < 16;
    confess "parse_chan_note bad note parsed out of $arg" unless $note >= 0 && $note < 128;
    return $chan, $note;
}

sub index_from_chan_note {
    my ($chan, $note) = @_;
    return $chan * 128 + $note;
}

sub find_slots_for_seqs {
    my ($comp_hash, $nslots, $input_channel) = @_;
    my @slots;
    my $count = 0;
    LOOP: for (my $i = 0; $i < 16; $i++){
        next if defined($input_channel) && $i != $input_channel;
        for (my $j = $MinImportNote; $j <= $MaxImportNote; $j++){
            my $s = "$i.$j";
            if (!defined($comp_hash->{$s})){
                push @slots, $s;
                $count++;
                last LOOP if $count >= $nslots;
            }            
        }
    }
    confess "Failed to find $nslots slots" unless $count == $nslots;
    return @slots;
}


## fetch midi using midicsv. Note, we throw non channel level messages away. We also ignore the channel argument.
sub fetch_midi {
    my ($filename) = @_;
    my @midi;
    my $TPQN = 960; 
    my %want = (map {$_ => 1} qw/ Header Note_on_c Note_off_c Pitch_bend_c Control_c /);
    for my $line (backtick("$MidiCsvPath $filename")){
        my ($track, $time, $command, @rest) = split ', ', $line;
        
        next unless $want{$command};
        if ($TPQN != 960) {
            $time = int( ($time/$TPQN) * 960 );
        }
        if ($command eq 'Note_on_c' || $command eq 'Note_off_c'){
            my ($channel, $note, $vel) = @rest;
            push @midi, [$time, $command, $note, $vel, {}];
        } elsif ($command eq 'Pitch_bend_c') {
            my ($channel, $value) = @rest;
            my $msb = (($value >> 7) & 0x7F);
            my $lsb = ($value & 0x7F);
            push @midi, [$time, $command, $msb, $lsb, {}];
        } elsif ($command eq 'Command_c'){
            my ($channel, $cc, $value) = @rest;
            push @midi, [$time, $command, $cc, $value, {}];
        } elsif ($command eq 'Header'){
            ## NOTE: the Header command is ALWAYS the first command, so if it's present this should all work.
            my ($format, $nTracks, $division) = @rest;
            $TPQN = $division;
        }
    }
    return {midi=>\@midi, meta=>scan_filename_meta($filename), filename=>$filename};
}

sub find_slice_notes {
    my ($filename, $slice_note) = @_;
    $slice_note = note_from_text($slice_note);
    my $TPQN = 960;
    my @slices;
    for my $line (backtick("$MidiCsvPath $filename")){
        my ($track, $time, $command, @rest) = split ', ', $line;
        if ($TPQN != 960) {
            $time = int( ($time/$TPQN) * 960 );
        }

        if ($command eq 'Note_on_c'){
            my ($channel, $note) = @rest;
            push @slices, $time if $note == $slice_note;
        } elsif ($command eq 'Header') {
            ## NOTE: the Header command is ALWAYS the first command, so if it's present this should all work.
            my ($format, $nTracks, $division) = @rest;
            $TPQN = $division;
        }    
    }
    return @slices;
}

## mark end group adds an element to the end of each midi row that represents if that midi row should be part
## of the sequences end-group. The end-group is characterized as the group of notes that ALL have the last time stamp
## in the sequence.
sub mark_end_group {
    my ($midi) = @_;
    my $lastTime = -1;
    for my $row (@$midi){
        if ($row->[1] eq 'Note_on_c' && $row->[0] > $lastTime){
            $lastTime = $row->[0];
        }
    }
    for my $row (@$midi){
        if ($row->[1] eq 'Note_on_c' && $row->[0] == $lastTime){
            $row->[4]{end_group} = 1;
        } 
    }
}

sub sequence_length {
    my ($midi, $lengthBars, $timeSig) = @_;
    my $latestTime = $midi->[$#$midi][0];
    my $bars = $latestTime/($timeSig*960.0);
    if ($bars != int($bars)) {
        $bars = int($bars) + 1
    }
    return $bars unless defined($lengthBars);

    confess "sequence_length got bad combination of midi/lengthBars" if ($lengthBars < $bars);
    return $lengthBars;
}

sub compress_midi_row {
    my ($time, $command, $b1, $b2, $isEndGroup, $isNoteCycle) = @_;
    my $c = ($b1 & 0x7F);
    $c    = $c | (($b2 & 0x7F) << 8);
    $c    = $c | (($isEndGroup  ? 1 : 0) << 16);
    $c    = $c | (($isNoteCycle ? 1 : 0) << 17);

    my $ksb_command = $com2com{$command};
    confess "Failed to find com2com for $command" unless defined($ksb_command);
    return ($time, $ksb_command, $c);
}

sub compress_midi {
    my ($midi) = @_;
    my @comp;
    for my $row (@$midi){
        push @comp, [compress_midi_row($row->[0], $row->[1], $row->[2], $row->[3], 
                                       $row->[4]{end_group}, $row->[4]{note_cycle})];
    }
    return \@comp;
}

sub render_list_by_block {
    my ($list, $tab) = @_;
    $tab ||= "";
    my $l = @$list;
    my $b = "";
    for (my $i = 0; $i < $l; $i++){
        if (length($b) >= $LineLength) {
            print "$tab$b...\n";
            $b = "";
        }
        $b .= $list->[$i];
        if ($i != $l-1){
            $b .= ', ';
        }
    }
    if (length($b) > 0) {
        print "$tab$b...\n";
    }
}



sub main_compile {
    ## Slurp the midi files
    my ($comp_files_map, $comp_files_list) = list_compile_files();
    confess "Didn't find any midi files" if (!@$comp_files_list);

    my $needed_slots = 0;
    my @midi_list;
    for my $file (@$comp_files_list){
        my $midi = fetch_midi($file);
        my ($chan, $note) = parse_chan_note($file);
        my $need = index_from_chan_note($chan, $note)+1;
        $needed_slots = $need if ($need > $needed_slots);
        $midi->{slot} = "$chan.$note";
        mark_end_group($midi->{midi});
        $midi->{midi} = compress_midi($midi->{midi});
        push @midi_list, $midi;
    }
    ## Initialize note_mape
    my @note_map;
    for (my $i = 0; $i < $needed_slots; $i++) {
        push @note_map, 0, 0, 0;
    }

    my ($start, $end) = (0, 0);
    for my $midi (@midi_list) {
        $start  = $end;
        $end   += scalar(@{$midi->{midi}});

        my $cg  = $midi->{meta}{cg};
        $cg = $DefaultChokeGroup unless defined($cg);
        my $ch  = $midi->{meta}{ch};
        $ch = $DefaultChannel unless defined($ch);
        die "Bad choke-group $cg for file $midi->{filename}" if $cg < $MinChokeGroup || $cg > $MaxChokeGroup;
        die "Bad channel $ch for file $midi->{filename}" if $ch < 0 || $ch > 15;

        my $flag_word = (($ch & 0xF) << 4) | ($cg & 0xF);

        my ($chan, $note) = parse_chan_note($midi->{slot});
        my $note_root           = 3*index_from_chan_note($chan, $note);
        $note_map[$note_root]   = $flag_word;
        $note_map[$note_root+1] = $start;
        $note_map[$note_root+2] = $end;
    }

    ## Set the variables in the script
    my @all_midi;
    for my $midi (@midi_list) {
        for my $row (@{$midi->{midi}}) {
            push @all_midi, @$row;
        }
    }
    my $note_map_fields_per_slot = 3;
    my %variables = (
        NoteMapSlots          => scalar(@midi_list), 
        NoteMapFieldsPerSlot  => $note_map_fields_per_slot,

        MidiDataSlots         => scalar(@all_midi),
        MidiDataFieldsPerSlot => 3,

        NoteMapLength         => $note_map_fields_per_slot*$needed_slots,
    );

    my $include_console = 0;

    ## Expand the ksb script template
    open my $fd, '<', \$TheNucleus or confess "INTERNAL ERROR: can't open string for reading";
    while (<$fd>){
        chomp;
        if (/\[\[NOTE_MAP\]\]/){
            render_list_by_block(\@note_map, "         ");
        } elsif (/\[\[MIDI_DATA\]\]/){ 
            render_list_by_block(\@all_midi, "         ");
        } elsif (/^(\s*)\#\#(.*)$/){
            ## Replace comments with stupid KSP comments.
            my $p = $1;
            (my $t = $2) =~ s/\r//g;
            print $p, '{#', $t, '}', "\n";
        } elsif (/\[\[FILES\]\]/) {
            print "pwd   = ", backtick("pwd"), "\n";
            print "time  = ", now(), "\n";
            print "files = ------------------\n";
            for my $file (@$comp_files_list) {
                print "        $file\n"
            }
            print "--------------------------\n";
        } elsif (/\[\[CONSOLE\]\]/) {
            print <<'END' if $include_console;
    declare ui_label $cons (6,6)
    { # Add text to the console with add_text_line($cons, <TEXT>) }
END
        } elsif (/\[\[MP_DECLARE\]\]/) {
            for (my $cg = 0; $cg < 16; $cg++){
                my $m = $MpPlayDeclare;  
                $m =~ s/^(\s*)\#\#(.*)$/"$1\{# $2\}\n"/mg;  
                $m =~ s/\[\[CG\]\]/$cg/g;
                print $m, "\n";
            }
        } elsif (/\[\[MP_BODY_(\d+)\]\]/) {
            my $cg = $1;    
            my $m = $MpPlayBody;  
            $m =~ s/^(\s*)\#\#(.*)$/$1\{# $2\}/mg;    
            $m =~ s/\[\[CG\]\]/$cg/g;
            print $m, "\n";
        } else {
            s/\[\[(.*)\]\]/$variables{$1}/g;
            print "$_\n";
        }
    }
}

sub main_import {
    my @abort_list;
    my @rm_list;
    my $log_block = 'Time: ' . now() . "\n";
    eval {
        my ($comp_files_map, $comp_files_list) = list_compile_files();
        my $noncomp_files = list_noncompile_files();
        @rm_list = @$noncomp_files;
        confess "No importable midi files found" unless @rm_list;
        for my $nc_file (@$noncomp_files){
            my $midi = fetch_midi($nc_file);
            my @slice = (0);
            if (defined($midi->{meta}{sn})){
                @slice = find_slice_notes($nc_file, $midi->{meta}{sn});
            }

            ## figure out which slice to use
            my @slots = find_slots_for_seqs($comp_files_map, scalar(@slice), $midi->{meta}{ic});
            
            my ($opts) = ($nc_file =~ /(_.*)\.mid$/);
            if ($opts){
                ## Remove import options
                $opts =~ s/_sn[^_]*//;
                $opts =~ s/_ic[^_]*//;
            }

            for (my $i = 0; $i < @slice; $i++) {
                my ($chan, $note) = parse_chan_note($slots[$i]);
                my $lex   = lex_from_chan_note($chan, $note);
                my $trans = transpose_from_note($note);
                my $rest = $opts;
                $rest .= ("_sl" . $slice[$i]) unless ($slice[$i] == 0);
                my $nfile = "$lex.$slots[$i]$trans$rest.mid";
                push @abort_list, $nfile;
                $comp_files_map->{$slots[$i]} = $nfile;
                my $cmd = "cp $nc_file $nfile";
                $log_block .= "    $cmd\n";
                run $cmd;
            }
        }
    };
    if ($@){
        run "rm -f @abort_list";
        confess $@;
    } else {
        run "rm @rm_list";
    }

    open my $fd, ">>", $LogFile or confess "Failed to open $LogFile: $!";
    print {$fd} $log_block,"\n";
    close($fd);
}

$MpPlayDeclare = <<'MP_PLAY_DECLARE';
    declare $mpCallback[[CG]] := 0
    declare $mpStoper[[CG]]   := 0
    declare $mpChannel[[CG]]  := 0
    declare $mpCounter[[CG]]
    declare $mpSeqTriggerEngaged[[CG]] := 0
    declare $mpPlayhead[[CG]] := -1
    declare $mpSeqEnd[[CG]]   := 0
    declare $mpSeqStart[[CG]] := 0
    declare $mpMark[[CG]]
    declare $mpMidiDesc[[CG]]
    declare $mpCommand[[CG]]
    declare $mpB1_[[CG]]
    declare $mpB2_[[CG]]
    declare $mpTicks[[CG]]
    declare $mpStartMilliseconds[[CG]]
    declare $mpIsInEndGroup[[CG]]
MP_PLAY_DECLARE

$MpPlayBody = <<'MP_PLAY_BODY';
                ## Stop existing callback if needed
                if ($mpCallback[[CG]] # 0)
                    $mpStoper[[CG]] := $mpCallback[[CG]]
                    $mpCallback[[CG]] := 0
                    stop_wait($mpStoper[[CG]], 1)
                end if

                ## Turn all notes off that this CG is responsible for
                $mpCounter[[CG]] := 0
                while ($mpCounter[[CG]] < 128)
                    if (%bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpCounter[[CG]]] = [[CG]])
                        set_midi($mpChannel[[CG]], $MIDI_COMMAND_NOTE_OFF, $mpCounter[[CG]], 0)
                        %bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpCounter[[CG]]] := -1
                    end if
                    inc($mpCounter[[CG]])
                end while

                ## Clear the pitch bend. XXX: this needs to be bracketed
                ## set_midi($mpChannel[[CG]], $MIDI_COMMAND_PITCH_BEND, 0, 0)    
                
                ## Now setup new sequence
                $mpChannel[[CG]]    := (sh_right(%noteMap[$stNoteRoot], 4) .and. 15)
                $mpSeqStart[[CG]]   := %noteMap[$stNoteRoot+1]
                $mpPlayhead[[CG]]   := $mpSeqStart[[CG]]
                $mpSeqEnd[[CG]]     := %noteMap[$stNoteRoot+2]
                $mpCallback[[CG]]   := $NI_CALLBACK_ID

                $mpStartMilliseconds[[CG]] := $ENGINE_UPTIME
                while ($mpPlayhead[[CG]] < $mpSeqEnd[[CG]])
                    $mpTicks[[CG]] := real_to_int( 960.0  ...
                                                            * int_to_real($ENGINE_UPTIME-$mpStartMilliseconds[[CG]])*1000.0...
                                                            / int_to_real($DURATION_QUARTER))
                    $mpMark[[CG]]  := %midiData[$MidiDataFieldsPerSlot*$mpPlayhead[[CG]]]

                    $mpCommand[[CG]]  := %midiData[$MidiDataFieldsPerSlot*$mpPlayhead[[CG]]+1]
                    $mpMidiDesc[[CG]] := %midiData[$MidiDataFieldsPerSlot*$mpPlayhead[[CG]]+2]
                    $mpB1_[[CG]]       := $mpMidiDesc[[CG]] .and. 127
                    $mpB2_[[CG]]       := sh_right($mpMidiDesc[[CG]], 8) .and. 127
                    
                    if ($mpMark[[CG]] > $mpTicks[[CG]])             
                        wait_ticks($mpMark[[CG]]-$mpTicks[[CG]])
                        if ($mpCallback[[CG]] # $NI_CALLBACK_ID)
                            exit
                        end if
                    end if

                    if (%bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpB1_[[CG]]] >= 0)                        
                        set_midi($mpChannel[[CG]], $MIDI_COMMAND_NOTE_OFF, $mpB1_[[CG]], 0)
                        %bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpB1_[[CG]]] := -1                        
                    end if

                    select ($mpCommand[[CG]])
                        case $MIDI_COMMAND_NOTE_ON
                            if ($mpB2_[[CG]] = 0)
                                %bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpB1_[[CG]]] := -1
                            else
                                %bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpB1_[[CG]]] := [[CG]]
                            end if

                        case $MIDI_COMMAND_NOTE_OFF
                            %bcExpectingNoteOffs[128 * $mpChannel[[CG]] + $mpB1_[[CG]]] := -1
                    end select

                    set_midi($mpChannel[[CG]], $mpCommand[[CG]], $mpB1_[[CG]], $mpB2_[[CG]])
                    
                    inc($mpPlayhead[[CG]])
                end while
                $mpCallback[[CG]] := 0
MP_PLAY_BODY

$TheNucleus = <<'KSB_SCRIPT_END';
on init
    set_script_title("CeeGuitar")

    ## Constants
    declare const $NoteMapSlots          := [[NoteMapSlots]]
    declare const $NoteMapFieldsPerSlot  := [[NoteMapFieldsPerSlot]]
    declare const $MidiDataSlots         := [[MidiDataSlots]]
    declare const $MidiDataFieldsPerSlot := [[MidiDataFieldsPerSlot]]
    declare const $NoteMapLength         := [[NoteMapLength]]
    declare const $NumChokeGroups        := 16

    declare const $A := $MIDI_COMMAND_NOTE_ON
    declare const $O := $MIDI_COMMAND_NOTE_OFF
    declare const $P := $MIDI_COMMAND_PITCH_BEND
    declare const $C := $MIDI_COMMAND_CC
    
    declare %noteMap[ $NoteMapLength ] := (...
        [[NOTE_MAP]]
    )
    declare %midiData[ $MidiDataFieldsPerSlot * $MidiDataSlots ] := (...
        [[MIDI_DATA]]
    )

    ## Short term variables are shared b/w all threads
    declare $stNoteRoot
    declare $stChokeGroup

    ## Expecting NoteOffs is indexed by channel (i.e. bc)
    declare %bcExpectingNoteOffs[$NumChokeGroups * 128] := (0)

    [[MP_DECLARE]]

    declare $note_counter := 0
    ##declare $note_counter_start := 0
    

    [[CONSOLE]]
end on

on midi_in
    ignore_midi

if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 > 0)        
    inc($note_counter)
    message($note_counter)
end if
    

    ##if ($note_counter_start = 0)
    ##    $note_counter_start := $ENGINE_UPTIME
    ##end if

    ##inc($note_counter)
    ##if ($note_counter mod 100 = 0)
    ##    
    ##    message(1000.0*int_to_real($note_counter) / int_to_real($ENGINE_UPTIME-$note_counter_start))
    ##    
    ##end if


    $stNoteRoot := ($MIDI_CHANNEL * 128 + $MIDI_BYTE_1)*$NoteMapFieldsPerSlot
    if ($stNoteRoot >= $NoteMapLength or %noteMap[$stNoteRoot+1] = %noteMap[$stNoteRoot+2])
        ## There are NO sequences beyond $NoteMapLength OR the sequence is empty
        exit
    end if

    if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 > 0)    
        $stChokeGroup := %noteMap[$stNoteRoot] .and. 15
        select ($stChokeGroup)
            case 0
                [[MP_BODY_0]]
                exit
            case 1
                [[MP_BODY_1]]
                exit
            case 2
                [[MP_BODY_2]]
                exit
            case 3
                [[MP_BODY_3]]
                exit
            case 4
                [[MP_BODY_4]]
                exit
            case 5
                [[MP_BODY_5]]
                exit
            case 6
                [[MP_BODY_6]]
                exit
            case 7
                [[MP_BODY_7]]
                exit
            case 8
                [[MP_BODY_8]]
                exit
            case 9
                [[MP_BODY_9]]
                exit
            case 10
                [[MP_BODY_10]]
                exit
            case 11
                [[MP_BODY_11]]
                exit
            case 12
                [[MP_BODY_12]]
                exit
            case 13
                [[MP_BODY_13]]
                exit
            case 14
                [[MP_BODY_14]]
                exit
            case 15
                [[MP_BODY_15]]
                exit
        end select
    end if

    if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_OFF or ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 = 0))

    end if
end on

## *** META ***
## *** META ***
## *** META ***
{
[[FILES]]
}
KSB_SCRIPT_END


##
## Flat calculation
##

my $Flat_PerSeq_Declare = <<'END';
    declare $ticks[[SEQ]]
    declare $seq_start[[SEQ]]
    declare $i[[SEQ]]
END

my $FlatNoteOn = <<'END';
            ## NoteOn cg=[[CG]] ch=[[CHAN]] bb1=[[BB1]] bb2=[[BB2]]
            $ticks[[SEQ]] := real_to_int( 960.0  ...
                                          * int_to_real($ENGINE_UPTIME-$seq_start[[SEQ]])*1000.0...
                                          / int_to_real($DURATION_QUARTER))
            if ([[MARK]] > $ticks[[SEQ]])             
                wait_ticks([[MARK]]-$ticks[[SEQ]])
                if ($Callback[[CG]] # $NI_CALLBACK_ID)
                    exit
                end if
            end if
            if (%offs[ [[CHAN]] * 128 + [[BB1]] ] >= 0)                        
                set_midi([[CHAN]], $MIDI_COMMAND_NOTE_OFF, [[BB1]], 0)
            end if
            %offs[  [[CHAN]] * 128 + [[BB1]] ] := [[CG]]
            set_midi([[CHAN]], $MIDI_COMMAND_NOTE_ON, [[BB1]], [[BB2]])
END

my $FlatNoteOff = <<'END';
            ## NoteOff cg=[[CG]] ch=[[CHAN]] bb1=[[BB1]] bb2=[[BB2]]
            $ticks[[SEQ]] := real_to_int( 960.0  ...
                                          * int_to_real($ENGINE_UPTIME-$seq_start[[SEQ]])*1000.0...
                                          / int_to_real($DURATION_QUARTER))
            if ([[MARK]] > $ticks[[SEQ]])             
                wait_ticks([[MARK]]-$ticks[[SEQ]])
                if ($Callback[[CG]] # $NI_CALLBACK_ID)
                    exit
                end if
            end if
            if (%offs[ [[CHAN]] * 128 + [[BB1]] ] >= 0)                        
                set_midi([[CHAN]], $MIDI_COMMAND_NOTE_OFF, [[BB1]], 0)
                %offs[ [[CHAN]] * 128 + [[BB1]] ] := -1                        
            end if
END

my $Flat_Preamble = <<'END';
        case [[SEQ]]
            ## Stop existing callback if needed
            if ($Callback[[CG]] # 0)
                stop_wait($Callback[[CG]], 1)
                $Callback[[CG]] := 0
            end if
            $i[[SEQ]] := 0
            while ($i[[SEQ]] < 128)
                if (%offs[ 128 * [[CHAN]] + $i[[SEQ]] ] = [[CG]])
                    set_midi([[CHAN]], $MIDI_COMMAND_NOTE_OFF, $i[[SEQ]], 0)
                end if
                inc($i[[SEQ]])
            end while
            $Callback[[CG]]   := $NI_CALLBACK_ID
            $seq_start[[SEQ]] := $ENGINE_UPTIME
END

my $Flat_CG_Global_Declare = <<'END'
    declare const $PLAYER_QUEUE   := 1
    declare const $PLAYER_RUNNING := 2
    declare const $PLAYER_DONE    := 3
END

my $Flat_CG_Declare = <<'END'
    declare $player_needsinit[[CG]] := 1
    declare $player_state[[CG]]
    declare $player_index[[CG]]
END

my $Flat_CG_Player = <<'END';
function trampoline[[CG]]
    while (1 = 1)
        if ($player_state[[CG]] = $PLAYER_QUEUE)
            call play[[CG]]
        else 
            wait(1000000)
        end if
    end while
end function

function play[[CG]]
    select ($player_index[[CG]])
        [[PLAY_LATTICE]]
    end select
end function
END

my $Flat_CG_dispatch = <<'END'
    case [[SEQ]]
        $player_state[[CG]] := $PLAYER_QUEUE
        $player_index[[CG]] := [[SEQ]]
        stop_wait($Callback[[CG]])
        exit
END

my $Flat_Skelaton = <<'END';
on init
    declare %offs[16 * 128]
    declare $index

    [[DECLARE]]
end on

[[PLAYER]]

on midi_in
    ignore_midi
    if ($MIDI_COMMAND # $MIDI_COMMAND_NOTE_ON)
        exit
    end if
    $index := $MIDI_CHANNEL*128 + $MIDI_BYTE_1
    select ($index)
        [[DISPATCH]]
    end select
end on

{# *** META *** }
{# *** META *** }
{# *** META *** }
{
[[META]]
}
END

sub expand_comment {
    my ($s) = @_;
    $s =~ s/^(\s*)\#\#(.*)$/$1\{# $2\}/mg;  
    return $s;
}

sub expand_symbols {
    my ($s, $h) = @_;
    $s =~ s/\[\[([^\[\]]*?)\]\]/$h->{$1}/g;
    return $s;
}

sub expand__tab {
    my ($s, $tab) = @_;
    $s =~ s/^(.*)$/$tab$1/mg;
    return $s;
}

sub write_declare {
    my ($midi_list) = @_;
    for my $midi (@$midi_list){
        my ($chan, $note) = parse_chan_note($midi->{slot});
        my $note_index = $chan * 128 + $note;
        my %h = (SEQ => $note_index);
        print expand_symbols(expand_comment($Flat_PerSeq_Declare), \%h), "\n";
    }
    for (my $i = 0; $i < 16; $i++){
        print "    declare \$Callback$i\n";
    }
}

sub write_lattice {
    my ($midi_list) = @_;
    for my $midi (@$midi_list){
        my ($chan, $note) = parse_chan_note($midi->{slot});
        my $note_index = $chan * 128 + $note;
        my $cg = $midi->{cg};
        $cg = $DefaultChokeGroup unless defined($cg);
        my %stab = (SEQ => $note_index, CHAN => $chan, CG=>$cg);
        my $preamble = expand_symbols(expand_comment($Flat_Preamble), \%stab);
        print $preamble,"\n";

        my @m = @{$midi->{midi}};
        for (my $i = 0; $i < @m; $i++){
            my $row = $m[$i];
            next unless $row->[1] =~ /^Note_o/;
            my ($mark, $command, $note, $vel) = @$row;
            my %h = %stab;
            $h{MARK} = $mark;
            $h{BB1}  = $note;
            $h{BB2}  = $vel;
            my $template = $command eq 'Note_on_c' ? $FlatNoteOn : $FlatNoteOff;
            print expand_symbols(expand_comment($template), \%h), "\n";

        }
    }
}

sub main_flat_compile {
    ## Slurp the midi files
    my ($comp_files_map, $comp_files_list) = list_compile_files();
    confess "Didn't find any midi files" if (!@$comp_files_list);

    my $needed_slots = 0;
    my @midi_list;
    for my $file (@$comp_files_list){
        my $midi = fetch_midi($file);
        my ($chan, $note) = parse_chan_note($file);
        my $need = index_from_chan_note($chan, $note)+1;
        $needed_slots = $need if ($need > $needed_slots);
        $midi->{slot} = "$chan.$note";
        push @midi_list, $midi;
    }

    ## Expand the ksb script template
    open my $fd, '<', \$Flat_Skelaton or confess "INTERNAL ERROR: can't open string for reading";
    while (<$fd>){
        chomp;
        if (/\[\[DECLARE\]\]/){
            write_declare(\@midi_list);
        } elsif (/\[\[DISPATCH\]\]/){ 
            write_lattice(\@midi_list);
        } elsif (/\[\[META\]\]/){
            print "pwd   = ", backtick("pwd"), "\n";
            print "time  = ", now(), "\n";
            print "files = ------------------\n";
            for my $file (@$comp_files_list) {
                print "        $file\n"
            }
            print "--------------------------\n";

        } else {
            print "$_\n";
        }
    }
}

sub main {
    my ($command) = @ARGV;
    shift @ARGV if @ARGV;
    $command = "compile" unless defined($command);
    if ($command eq 'compile'){
        main_compile();
        return;
    } elsif ($command eq 'import'){
        main_import();
        return;
    } elsif ($command eq 'flat_compile'){
        main_flat_compile();
        return;
    } 

    confess "Unknown command $command";
}


main();
